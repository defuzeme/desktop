/*******************************************************************************
**  defuze.me - modern radio automation software suite
**  
**  Copyright Â© 2012
**    Athena Calmettes - Jocelyn De La Rosa - Francois Gaillard
**    Adrien Jarthon - Alexandre Moore - Luc Peres - Arnaud Sellier
**
**  website: http://defuze.me
**  contact: team@defuze.me
**
**  This program is free software: you can redistribute it and/or modify it
**  under the terms of the GNU Lesser General Public License as published by
**  the Free Software Foundation, either version 3 of the License, or
**  (at your option) any later version.
**
**  This program is distributed in the hope that it will be useful,
**  but WITHOUT ANY WARRANTY; without even the implied warranty of
**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
**  GNU Lesser General Public License for more details.
**
**  You should have received a copy of the GNU Lesser General Public License
**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
**
**  This software includes code from Nokia (Qt) under the GNU LGPLv2.1
**  This software uses libraries from the FFmpeg project under the GNU LGPLv2.1
**  This software uses libraries from the TagLib project under the GNU LGPLv2.1
**
*******************************************************************************/

namespace Network {
	class Doorman;
}

#ifndef DOORMAN_HPP
#define DOORMAN_HPP

#include <QObject>
#include <QTcpServer>
#include <QTcpSocket>
#include "remoteevent.hpp"
#include "remotesock.hpp"
#include "dbcore.hpp"
#include "parameterizable.hpp"

namespace Network
{
	/** The doorman filter remote control connections.
	  * It uses white & black lists stored in the database, and ask the user for unknow devices.
	  * The devices will be identified by a unique key generated by the mobile application.
	  **/

	class Doorman : public Params::Parameterizable
	{
		Q_OBJECT
	public:
		Doorman(QTcpServer *rcServer);
		void				loadKnownDevices();
		void				storeKnownDevices();

	signals:
		void				authenticatedRemote(RemoteSock*);		///< emited when a client has successfully been authenticated
		void				needAuthorization(const RemoteEvent&);	///< emited when user's approval is needed

	public slots:
		void				newConnection();						///< called when a new client connects
		void				authentication(const RemoteEvent&);		///< called when an authentication event is received
		void				answered(RemoteSock*, unsigned, bool, bool);	///< called when the user answer through the dialog

	private:
		void				defineParams();							///< Load default params (called by parameterizable)
		QTcpServer			*rcServer;
		QVariantMap			knownDevices;
	};
}

#endif // DOORMAN_HPP
